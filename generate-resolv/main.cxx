/*
 * Generate AIX resolv.conf from IBM i TCP attributes
 *
 * Copyright (C) 2022 Seiden Group
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

extern "C" {
	#include <ctype.h>
	#include <stdio.h>
	#include <stdbool.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <string.h>
	#include <unistd.h>
	
	#include "../libsiteadd-c/errc.h"
	#include "QtocRtvTCPA.h"
	#include "../libsiteadd-c/ebcdic.h"
}

#include "../libsiteadd-c/ebcdic.hxx"
#include "../libsiteadd-c/ilefunc.hxx"

EF<8> TCPA1400_name("TCPA1400");

// surprisingly, output length is int* and not int
static auto QtocRtvTCPA = ILEFunction<void, void*, int*, const char*, ERRC0100*>("QSYS/QTOCNETSTS", "QtocRtvTCPA");

void
print_domain(Qtoc_RtvTCPA_TCPA1400_t *tcp1400)
{
	char domain_name[255 * 6];
	ebcdic2utf (tcp1400->Domain_Name, 255, domain_name);
	/* truncate spaces */
	char *first_space = strchr(domain_name, ' ');
	if (first_space) {
		*first_space = '\0';
	}
	printf("domain %s\n", domain_name);
}

void
print_search(Qtoc_RtvTCPA_TCPA1400_t *tcp1400)
{
	char search_list[256 * 6];
	ebcdic2utf (tcp1400->Domain_Search_List, 256, search_list);
	/* truncate spaces *at end* */
	for (size_t i = strlen(search_list); i != 0; i--) {
		if (isspace(search_list[i])) {
			search_list[i] = '\0';
		}
	}
	printf("search %s\n", search_list);
}

void
print_options(Qtoc_RtvTCPA_TCPA1400_t *tcp1400)
{
	printf("options timeout:%u attempts:%u", tcp1400->Time_Interval, tcp1400->Retries);
	if (tcp1400->Initial_DNS_Server == 2) {
		printf(" rotate");
	}
	printf("\n");
}

void
print_nameservers(Qtoc_RtvTCPA_TCPA1100_t *tcp1100, Qtoc_RtvTCPA_TCPA1400_t *tcp1400)
{
	Qtoc_RtvTCPA_Inet_Addr_IP4_IP6_t *addresses = (Qtoc_RtvTCPA_Inet_Addr_IP4_IP6_t*)((char*)tcp1100 + tcp1400->Offset_To_List_DNS_Addr);
	for (size_t i = 0; i < tcp1400->Number_Of_DNS_Addresses; i++) {
		char address_string[45 * 6];
		ebcdic2utf (addresses[i].DNS_Internet_Address, 45, address_string);
		/* truncate spaces */
		char *first_space = strchr(address_string, ' ');
		if (first_space) {
			*first_space = '\0';
		}
		printf("nameserver %s\n", address_string);
	}
}

void
get_tcp_attribs (void)
{
	int outlen = 1000000;
	Qtoc_RtvTCPA_TCPA1100_t *out = (Qtoc_RtvTCPA_TCPA1100_t*)calloc(outlen, 1);
	out->Bytes_Available = outlen;
	ERRC0100 err = {};
	err.bytes_in = sizeof (err);
	
	QtocRtvTCPA(out, &outlen, TCPA1400_name.value, &err);
	if (err.exception_id [0] != '\0') {
		char code[8];
		ebcdic2utf(err.exception_id, 7, code);
		code[7] = '\0'; /* truncate */
		fprintf(stderr, "QtocRtvTCPA returned exception code %s\n", code);
		abort();
	}
	printf("# This was generated by a script from IBM i TCP attributes.\n");
	Qtoc_RtvTCPA_TCPA1400_t *tcpa1400 = (Qtoc_RtvTCPA_TCPA1400_t*)(((char*)out) + out->Offset_To_Additional_Info);
	print_domain(tcpa1400);
	print_search(tcpa1400);
	print_options(tcpa1400);
	print_nameservers(out, tcpa1400);
	free(out);
}

static void
usage (char *argv0)
{
	fprintf(stderr, "usage: %s\n", argv0);
}

int
main (int argc, char **argv)
{
	int ch;
	while ((ch = getopt (argc, argv, "")) != -1) {
		switch (ch) {
		default:
			usage (argv [0]);
			return 1;
		}
	}
	get_tcp_attribs ();
	return 0;
}
